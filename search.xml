<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringSecurity认证流程</title>
      <link href="/2023/10/24/SpringSecurity%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/10/24/SpringSecurity%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在学习 Ruoyi 后台管理框架源码，看到了关于 SpringSecurity 安全认证方面的东西，感觉不易理解，因此花了点时间时间看了源码，深入了解一下认证流程</p></blockquote><h2 id="springsecurity配置"><a class="markdownIt-Anchor" href="#springsecurity配置"></a> SpringSecurity配置</h2><p>我们需要做一定的配置才能让 SpringSecurity 的安全认证起到作用，下面我们定义一个 <code>SecurityConfig.java</code> 类，它继承了 <code>WebSecurityConfigurerAdapter</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step.1）同时需要重写它的 <code>configure(HttpSecurity http)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// CRSF禁用，不使用session</span></span><br><span class="line">    http.csrf().disable();</span><br><span class="line">    <span class="comment">// 基于token，所以不需要session</span></span><br><span class="line">    http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">    <span class="comment">// 过滤请求</span></span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/captchaImage&quot;</span>).anonymous()</span><br><span class="line">        .anyRequest().authenticated();</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 添加JWT filter</span></span><br><span class="line">    http.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置的相关解释如下：</p><ul><li>项目是前后端分离的，无需用到 session，因此修改与 session 相关的配置</li><li>定义哪些请求需要进行认证，哪些请求可以放行</li><li>定义过滤器（<strong>重要，如何从请求中拿到认证信息就靠它了</strong>）<ul><li>在项目中过滤器 <code>authenticationTokenFilter</code> 继承了 <code>OncePerRequestFilter</code></li><li>继承了 <code>OncePerRequestFilter</code> 的类在每次请求只执行一次</li></ul></li></ul><p>Step.2）此外我们还需要重写的它的 <code>configure(AuthenticationManagerBuilder auth)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    auth.userDetailsService(userDetailsService)</span><br><span class="line">        .passwordEncoder(bCryptPasswordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们使用了一个 <code>UserDetailsService</code> 对象（<strong>重要，判断用户认证是否成功也就是账号密码是否正确就靠它了</strong>）</p><p><em><strong>小总结</strong></em>：目前我们提到了两个重要，下面的文章就是围绕这两个<em>重要</em>进行展开的。下面我们将先阐述用户认证流程，然后在梳理如何拿到认证信息。</p><h2 id="用户认证流程"><a class="markdownIt-Anchor" href="#用户认证流程"></a> 用户认证流程</h2><p>用户认证所关注是<strong>用户所输入的账号信息是否正确</strong>，如果账号信息正确将返回一个凭证，下面的认证流程将围绕这个关注点展开。</p><h3 id="发送认证请求"><a class="markdownIt-Anchor" href="#发送认证请求"></a> 「发送认证请求」</h3><p>我们发送请求 <code>[post] /login</code>，传递 username、password 等数据到服务器，服务器收到请求，来到相应的 controller 处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysLoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysLoginService loginService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(String username, String password, String code, String uuid)</span>&#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> Result.success();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> loginService.login(username, password, code, uuid);</span><br><span class="line">        result.put(Constants.TOKEN, token);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这里调用 loginService 的 login方法，其中内部是具体的验证登录逻辑，验证通过后返回一个 token，也就是一个凭证，用来表示我们已近认证成功（登录成功）。</p><h3 id="调用认证方法"><a class="markdownIt-Anchor" href="#调用认证方法"></a> 「调用认证方法」</h3><p>接下来进入 <code>loginService.login()</code>内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysLoginService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, String code, String uuid)</span> &#123;</span><br><span class="line">        ...省去验证码校验逻辑，校验失败会抛出异常</span><br><span class="line">            </span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 认证 该方法会去调用UserDetailsServiceImpl.loadUserByUsername</span></span><br><span class="line">            authenticate = authenticationManager.authenticate(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserPasswordNotMatchException</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tokenService.createToken((LoginUser) authenticate.getPrincipal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>authenticationManager.authenticate()</code> 就是我们需要调用的认证方法，如果失败则抛出异常。</p><p>这个方法以一个 <code>UsernamePasswordAuthenticationToken</code> 类作为参数，它拥有两个构造方法，如下：</p><ul><li><p>只有两个参数的构造方法表示「当前没有认证」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span></span><br></pre></td></tr></table></figure></li><li><p>有三个参数的构造方法表示「当前已经认证完毕」，后面校验成功后会用到它</p><p><img src="1491349-20210212111209270-25593274.png" alt="image-20210211230717227" /></p></li></ul><h3 id="源码分析认证方法"><a class="markdownIt-Anchor" href="#源码分析认证方法"></a> 「源码分析认证方法」</h3><p><img src="1491349-20210212111214429-1207745914.png" alt="png" /></p><p>上面的流程图就是认证方法的一个大概过程，下面我们将通过源码来查看这个认证方法 <code>AuthenticationManager.authenticate()</code> 到底干了什么（<em>深入源码调用堆栈有点啰嗦，可以直接看第5步的小总结</em>）。</p><p>Step.1）实现了<code>AuthenticationMananger</code>的<code>ProviderManger</code>调用接口的<code>authenticate</code>方法</p><p><img src="1491349-20210212111218902-477924771.png" alt="image-20210211221629377" /></p><p>Step.2）然后遍历所有的 AuthenticProvider，其中的<code>supports</code>方法用来判断 <code>provider</code> 是否支持 <code>toTest</code>。</p><p>而源码中的 <code>toTest</code> 类，就是我们认证传递的 <code>UsernamePasswordAuthenticationToken</code>，通过遍历我们发现 <code>AbstractUserDetailsAuthenticationProvider</code> 支持 <code>UsernamePasswordAuthenticationToken</code>，判断<code>provider</code>是否合适的源码如下：</p><p>AbstractUserDetailsAuthenticationProvider.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step.3）找到合适的Provider后，在本例中也即是AbstractUserDetailsAuthenticationProvider（抽象类），会调用provider 的authenticate 方法</p><p><img src="1491349-20210212111224769-231714021.png" alt="image-20210211224205852" /></p><p>Step.4）从下面可以看到  retrieveUser 方法返回一个 UserDetails</p><p><img src="1491349-20210212111229541-672939290.png" alt="image-20210211224415630" /></p><p>Step.5）接着深入，可以发现 DaoAuthenticationProvider 继承了 AbstractUserDetailsAuthenticationProvider，所以DaoAuthenticationProvider 才是真正的实现类，他会调用 retrieveUser  方法，接着调用 loaderUserByUsername() 方法</p><p><img src="1491349-20210212111232769-661828572.png" alt="image-20210211224719481" /></p><p>看到 loaderUserByUsername()，应该就很熟悉了，因为这就是我们自己实现 <code>UserDetailsService</code> 接口，自定义的认证过程。</p><p><strong>小总结</strong>：源码分析了一堆，其实这个<strong>认证方法的真正目的是调用 <code>UserDetailsService</code> 类的 <code>loaderUserByUsername()</code></strong></p><h3 id="实现校验逻辑"><a class="markdownIt-Anchor" href="#实现校验逻辑"></a> 「实现校验逻辑」</h3><p>文章开头我们提到了两个重要，第二个重要就是 <code>UserDetailsService</code>，认证就是通过它的 <code>loaderUserByUsername()</code> 方法是否认证成功。</p><p><code>UserDetailsService</code> 是一个接口，同时要求我们返回一个 <code>UserDetail</code> 对象，我们需要自己实现认证校验逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userDetailsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> ISysUserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> SysPermissionService permissionService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">SysUser</span> <span class="variable">user</span> <span class="operator">=</span> userService.selectUserByUserName(username);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == user) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;登录用户：&#123;&#125; 不存在.&quot;</span>, username);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;登录用户：&quot;</span> + username + <span class="string">&quot; 不存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UserStatus.DELETED.getCode().equals(user.getDelFlag())) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;登录用户：&#123;&#125; 已被删除.&quot;</span>, username);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;对不起，您的账号：&quot;</span> + username + <span class="string">&quot; 已被删除&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UserStatus.DISABLE.getCode().equals(user.getStatus())) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;登录用户：&#123;&#125; 已被停用.&quot;</span>, username);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BaseException</span>(<span class="string">&quot;对不起，您的账号：&quot;</span> + username + <span class="string">&quot; 已停用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createLoginUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">createLoginUser</span><span class="params">(SysUser user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user, permissionService.getMenuPermission(user));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是我们自己的认证逻辑：</p><ol><li>通过一个唯一标识 username 查询用户</li><li>当所有校验都通过后就会调用 createLoginUser 方法<ul><li>装填用户拥有的权限以及<strong>从数据库中获取的密码</strong>，</li></ul></li><li>返回一个 LoginUser 对象，而这个对象实现了 UserDetails接口。</li></ol><h3 id="源码分析校验逻辑"><a class="markdownIt-Anchor" href="#源码分析校验逻辑"></a> 「源码分析校验逻辑」</h3><p>下面我们通过源码查看获取到 <code>UserDetails</code> 后 SpringSecurity 还做了什么（<em>如果没看之前的源码分析可以直接看第2步的小总结</em>）</p><p>Step.1）我们回看 AbstractUserDetailsAuthenticationProvider 的 authenticate 方法</p><p><img src="1491349-20210212111242458-1187130244.png" alt="image-20210211230406093" /></p><p>Step.2）接着深入，可以发现<code>createSuccessAuthentication</code>方法创建了一个UsernamePasswordAuthenticationToken，并且他的构造方法<strong>有三个参数</strong>，这表明这个token是已近认证过后的</p><p><img src="1491349-20210212111246874-1801079482.png" alt="image-20210211230531473" /></p><p><strong>小总结</strong>：认证成功后，我们调用 <code>UsernamePasswordAuthenticationToken</code> 具有三个参数的构造方法，也就是代表认证成功的构造函数，然后将构造的对象返回去。</p><h3 id="认证结束"><a class="markdownIt-Anchor" href="#认证结束"></a> 「认证结束」</h3><p>至此认证已经结束，我再回到 <code>loginService.login()</code>这个我们自己写的方法内，认证方法 <code>authenticationManager.authenticate()</code> 认证成功后会返回一个 Authentication，然后就可以利用这个 Authentication 生成一个 token。</p><p>loginService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> tokenService.createToken((LoginUser) authenticate.getPrincipal());</span><br></pre></td></tr></table></figure><p>接着回到前面第二步controller调用的 <code>loginService.login()</code>，这时它已近拿到了 token ，于是将其返回到前端。前端收到相应后，就可以把这个token存在本地，以后每次访问请求时都带上这个token 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AjaxResult <span class="title function_">login</span><span class="params">(String username, String password, String code, String uuid)</span>&#123;</span><br><span class="line">    <span class="type">AjaxResult</span> <span class="variable">result</span> <span class="operator">=</span> AjaxResult.success();</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> loginService.login(username, password, code, uuid);</span><br><span class="line">    result.put(Constants.TOKEN, token);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取认证信息"><a class="markdownIt-Anchor" href="#获取认证信息"></a> 获取认证信息</h2><p>文章开头提到了两个重要，下面我们将梳理第一个重要，也就是如何从请求中拿到认证信息。</p><p>上面说到认证成功后每次发送请求都带上 token 信息，但是为啥带上这个 token 呢？在之前的 SpringSecurity 配置中有如下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/captchaImage&quot;</span>).anonymous()</span><br></pre></td></tr></table></figure><p>因此对于 <code>/login</code>请求没遭受拦截，而其他请求都是要被拦截的。</p><h3 id="拦截器"><a class="markdownIt-Anchor" href="#拦截器"></a> 「拦截器」</h3><p>之前 <code>/login</code>  我们配置了不拦截，因此手动调用 <code>authenticationManager.authenticate()</code> 来进行认证，而现在被拦截的请求又是如何判断它是否认证过了呢？</p><p>对于被拦截的请求，如果它带有 token，我们会手动将这个 token 转换为认证信息 <code>UsernamePasswordAuthenticationToken</code> 并放入本次请求的上下文中，否则啥事都不做。而我们文章开头所配置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(authenticationTokenFilter,UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure><p>拦截器就是起这个作用，具体实现如下（后面称这个为 jwtFilter）。</p><p>JwtAuthenticationTokenFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1)</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> tokenService.getLoginUser(request);</span><br><span class="line">        <span class="comment">// 2)</span></span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.isNotNull(loginUser) &amp;&amp; ObjectUtil.isNull(SecurityUtils.getAuthentication()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 3.1)</span></span><br><span class="line">            tokenService.verifyToken(loginUser);</span><br><span class="line">            <span class="comment">// 3.2)</span></span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">            authenticationToken.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们关注代码中 3.2）即可。在 token 正确后，我们使用用有三个参数的构造方法创建<code>UsernamePasswordAuthenticationToken</code> 对象，前面也说了，这代表已经经过认证，然后通过 <code>SecurityContextHolder.getContext().setAuthentication()</code> 为本次请求上下文设置一下认证信息。</p><p>这样后面 SpringSecurity 看到存在这个认证信息就会判断本次请求已经认证成功。</p><h3 id="源码分析拦截流程"><a class="markdownIt-Anchor" href="#源码分析拦截流程"></a> 「源码分析拦截流程」</h3><blockquote><p>为了更深刻的了解 SpringSecurity 内部是如何被拦截请求是否认证成功，我们接下来通过源码具体分析一下流程。</p></blockquote><p>再次之前先介绍一个类 <code>FilterSecurityInterceptor</code>：是一个方法级的权限过滤器，基本位于过滤链的最底部，因此请求到来时它一定会执行，下面来看看源码。</p><p><img src="1491349-20210212111253863-952441950.png" alt="image-20210212102053438" /></p><p>下面来打个断点，查看一下</p><p><img src="1491349-20210212111257853-1567880337.png" alt="image-20210212102439157" /></p><p>这说明来到<code>beforeInvocation</code>方法时我们前面编写的jwtFilter已经被执行，认证信息已近被手动添加过了</p><p><img src="1491349-20210212111301333-1915938085.png" alt="image-20210212102758021" /></p><p>进入<code>beforeInvocation()</code>里面，由调试信息可以看到当前请求需要被认证</p><p><img src="1491349-20210212111304839-493673989.png" alt="image-20210212103144116" /></p><p>接着我们进入<code>authenticateIfRequired</code>方法的内部</p><p><img src="1491349-20210212111309890-2103762999.png" alt="image-20210212103331881" /></p><p>因为我们之前 jwtfilter 手动添加了认证信息，所以<code>authenticateIfRequired</code>就直接返回了authentication，表示认证通过。</p><p>如果之前在 jwtfilter 被拦截的请求不存在 token，我们就不会手动设置认证信息，因此调用 <code>authenticationManager.authenticate();</code>进行验证时，中途一定会抛出异常，导致此次请求失败被拦截</p><p>至此也没啥好讲了，filterInvocation.getChain().doFilter() 调用我们的后台服务了</p><p><img src="1491349-20210212111313880-319009086.png" alt="image-20210212104009332" /></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://www.cnblogs.com/ymstars/p/10626786.html">https://www.cnblogs.com/ymstars/p/10626786.html</a></p><p><a href="https://www.jianshu.com/p/d5ce890c67f7">https://www.jianshu.com/p/d5ce890c67f7</a></p><p><a href="https://gitee.com/y_project/RuoYi-Vue">https://gitee.com/y_project/RuoYi-Vue</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring家族 </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的分库分表实践案例</title>
      <link href="/2023/10/24/%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B/"/>
      <url>/2023/10/24/%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于业务庞大，数据增长快，为了缓解数据库压力需要进行分库分表。本文的目标是展示一个具体的数据库路由组件的实践案例。这个案例通过自定义一个 springboot 的 starter 来实现。</p></blockquote><h2 id="什么是分库分表"><a class="markdownIt-Anchor" href="#什么是分库分表"></a> 什么是分库分表？</h2><p>分库分表其实很好理解，<strong>「顾名思义，即把存于一个库的数据分散到多个库中，把存于一个表的数据分散到多个表中」</strong>。分库分表有三种方案：</p><ul><li><strong>「只分库不分表」</strong></li><li><strong>「只分表不分库」</strong></li><li><strong>「既分库又分表」</strong></li></ul><h3 id="只分库不分表"><a class="markdownIt-Anchor" href="#只分库不分表"></a> 只分库不分表</h3><p><strong>「从单个数据库拆分成多个数据库的过程，将数据散落在多个数据库中，多个数据库同时提供服务」</strong></p><p><img src="modb_20220718_bf402a9c-0658-11ed-a8c9-38f9d3cd240d.png" alt="只分库不分表" /></p><h3 id="只分表不分库"><a class="markdownIt-Anchor" href="#只分表不分库"></a> 只分表不分库</h3><p><strong>「从单张表拆分成多张表的过程，将数据散落在多张表内」</strong></p><p><img src="modb_20220718_bf66ab04-0658-11ed-a8c9-38f9d3cd240d.png" alt="只分表不分库" /></p><h3 id="既分库又分表"><a class="markdownIt-Anchor" href="#既分库又分表"></a> 既分库又分表</h3><p><strong>「把存于一个数据库的单表数据分散到不同库的多个表中」</strong></p><p><img src="modb_20220718_c04e2d8a-0658-11ed-a8c9-38f9d3cd240d.png" alt="既分库又分表" /></p><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><h3 id="确定需要数据"><a class="markdownIt-Anchor" href="#确定需要数据"></a> 确定需要数据</h3><p>知道了分库分表的概念，我们就可以确定 starter 所需要的数据了</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mini-db-router:</span></span><br><span class="line">  <span class="attr">jdbc:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">db-count:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">tb-count:</span> <span class="number">4</span></span><br><span class="line">      <span class="attr">router-key:</span> <span class="string">uId</span></span><br><span class="line">      <span class="attr">default-db:</span> <span class="string">db00</span></span><br><span class="line">      <span class="attr">list:</span> <span class="string">db01,db02</span></span><br><span class="line">      <span class="attr">db-config-map:</span></span><br><span class="line">        <span class="attr">db00:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.56.101:3306/lottery?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">db01:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.56.101:3306/lottery_01?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">db02:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.56.101:3306/lottery_02?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><ul><li>dbCount：分库数</li><li>tbCount：分表数</li><li>routerKey：路由键，用来确定哪一个库，哪一个表</li><li>defaultDb：默认数据库</li><li>list：分库数据库列表</li><li>dbConfigMap：数据库配置</li></ul><h3 id="创建-properties"><a class="markdownIt-Anchor" href="#创建-properties"></a> 创建 Properties</h3><p>为了读取在 yaml 文件中的配置，我们创建 <code>Properties</code> 来帮助我们便捷的读取 yaml 数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mini-db-router.jdbc.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBRouterProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer dbCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer tbCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String defaultDb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String routerKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, DbConfig&gt; dbConfigMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DbConfig <span class="title function_">getDefaultDbConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dbConfigMap.get(defaultDb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DbConfig <span class="title function_">getDbConfig</span><span class="params">(String dbKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dbConfigMap.get(dbKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DbConfig</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String driverClassName;</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时如何决定库表"><a class="markdownIt-Anchor" href="#运行时如何决定库表"></a> 运行时如何决定库表？</h2><p>程序运行时我们需要判断具体要选择哪一个库，以及哪一个表，在这里就需要用到 <code>ThreadLocal</code>，它在线程中维护一个变量，并且能在同一线程中的任意上下文获取到这个变量，还起到线程间数据隔离的作用。</p><p>我们将 <code>dbKey</code> 以及 <code>tbKey</code> 用 <code>TreadLocal</code> 维护起来，它们两分别决定了该使用哪个库哪个表，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBContextHolder</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; dbKey = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; tbKey = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDbKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        dbKey.set(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDbKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dbKey.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setTbKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        tbKey.set(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTbKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tbKey.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearDbKey</span><span class="params">()</span> &#123;</span><br><span class="line">        dbKey.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearTbKey</span><span class="params">()</span> &#123;</span><br><span class="line">        tbKey.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只提到了如何维护 <code>dbKey</code> 和 <code>tbKey</code>，后面会再次说明如何设置以及使用这两个值</p><h2 id="设置-dbkey-以及-tbkey"><a class="markdownIt-Anchor" href="#设置-dbkey-以及-tbkey"></a> 设置 <code>dbKey</code> 以及 <code>tbKey</code></h2><p>前面提到可以说用 <code>DBContextHolder</code> 来维护 <code>dbKey</code> 以及 <code>tbKey</code> 这两个值，那何时去设置它们呢，这就要用到注解以及 aop 了。</p><p>只要在方法上标注了注解就说明我们想要分库分表了，然后借助 aop 就可以在执行数据库操作之前设置好 <code>dbKey</code> 以及 <code>tbKey</code> 这两个值。</p><h3 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h3><p><code>@DBRouter</code> 表明我们想要分库，同时可以用 key 来指定路由键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBRouter &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@DBRouterStrategy</code>  表明我们想要分表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBRouterStrategy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">splitTable</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建切面"><a class="markdownIt-Anchor" href="#创建切面"></a> 创建切面</h3><p>1、切点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.hemou.middleware.db.router.annotation.DBRouter)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aopPoint</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对标注了 <code>@DBRouter</code> 的地方进行增强</p><p>2、通知</p><p>我们使用环绕通知</p><p>1）我们获取 <code>@DBRouter</code> 上表明的路由键，若为空，则使用 yaml 中配置的默认路由键</p><p>2）通过路由键我们获取对应的路由值，大多数是全局唯一ID</p><p>3）根据路由值计算该路由到哪个库哪个表，（也就是设置 <code>dbKey</code> 以及 <code>tbKey</code>）</p><p>4）执行原本方法</p><p>5）原方法执行完毕后，清除 <code>dbKey</code> 以及 <code>tbKey</code>，避免内存泄露</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;aopPoint() &amp;&amp; @annotation(dbRouter)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doRouter</span><span class="params">(ProceedingJoinPoint jp, DBRouter dbRouter)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dbKey</span> <span class="operator">=</span> dbRouter.key();</span><br><span class="line">    dbKey = StringUtils.isNotBlank(dbKey) ? dbKey : dbRouterProperties.getRouterKey();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(dbKey)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;annotation DBRouter key is null!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算路由</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbKeyValue</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttrValue(dbKey, jp.getArgs());</span><br><span class="line">    dbRouterStrategy.doRouter(dbKeyValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jp.proceed();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 清除路由</span></span><br><span class="line">        dbRouterStrategy.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、具体路由值计算该路由到哪个库哪个表的方法</p><p>先通过 <code>dbCount</code> 以及 <code>tbCount</code> size，这个size必须是 2 的 n 次幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRouter</span><span class="params">(String dbKeyAttr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dbRouterProperties.getDbCount() * dbRouterProperties.getTbCount();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (size - <span class="number">1</span>) &amp; (dbKeyAttr.hashCode() ^ (dbKeyAttr.hashCode() &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">dbIdx</span> <span class="operator">=</span> idx / dbRouterProperties.getTbCount() + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tbIdx</span> <span class="operator">=</span> idx - dbRouterProperties.getTbCount() * (dbIdx - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DBContextHolder.setDbKey(String.format(<span class="string">&quot;%02d&quot;</span>, dbIdx));</span><br><span class="line">    DBContextHolder.setTbKey(String.format(<span class="string">&quot;%03d&quot;</span>, tbIdx));</span><br><span class="line">    log.debug(<span class="string">&quot;数据库路由 dbIdx：&#123;&#125; tbIdx：&#123;&#125;&quot;</span>,  dbIdx, tbIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分库-数据库动态切换"><a class="markdownIt-Anchor" href="#分库-数据库动态切换"></a> 分库 - 数据库动态切换</h2><p>因为进行了分库，所以数据库不止一个，这里我们就可以根据 <code>dbKey</code> 来决定到底使用哪一个库了。我们将继承一个 <code>AbstractRoutingDataSource</code> 类，它的 <code>determineCurrentLookupKey()</code> 方法能帮我们动态的切换数据库，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DBRouterProperties dbRouterProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicDataSource</span><span class="params">(DBRouterProperties dbRouterProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dbRouterProperties = dbRouterProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == DBContextHolder.getDbKey()) &#123;</span><br><span class="line">            <span class="keyword">return</span> dbRouterProperties.getDefaultDb();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;db&quot;</span> + DBContextHolder.getDbKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们判断 DBContextHolder 维护的 <code>dbKey</code> 是否为空，如果为空则使用默认数据库，否则使用指定数据库。</p><p>我们所继承的这个 <code>AbstractRoutingDataSource</code> 构建时要求我们输入一个 Map 集合，它键对应的值就是数据源对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(DBRouterProperties dbRouterProperties)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建数据源</span></span><br><span class="line">    Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, DbConfig&gt; entry : dbRouterProperties.getDbConfigMap().entrySet()) &#123;</span><br><span class="line">        <span class="type">DbConfig</span> <span class="variable">dbConfig</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        targetDataSources.put(entry.getKey(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>(dbConfig.getUrl(), dbConfig.getUsername(), dbConfig.getPassword()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据源</span></span><br><span class="line">    <span class="type">DynamicDataSource</span> <span class="variable">dynamicDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicDataSource</span>(dbRouterProperties);</span><br><span class="line">    dynamicDataSource.setTargetDataSources(targetDataSources);</span><br><span class="line">    dynamicDataSource.setDefaultTargetDataSource(targetDataSources.get(dbRouterProperties.getDefaultDb()));</span><br><span class="line">    <span class="keyword">return</span> dynamicDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 <code>determineCurrentLookupKey()</code> 就可以根据 <code>dbKey</code> 来决定具体的数据源</p><h2 id="分表"><a class="markdownIt-Anchor" href="#分表"></a> 分表</h2><p>通过创建 Mybatis 插件以及维护的 <code>tbKey</code>，我们为 SQL 语句所操作的数据表动态的添加后缀，从而起到分表的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class, Integer.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicMybatisPlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(from|into|update)[\\s]+(\\w+)&quot;</span>, Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取StatementHandler</span></span><br><span class="line">        <span class="type">StatementHandler</span> <span class="variable">statementHandler</span> <span class="operator">=</span> (StatementHandler) invocation.getTarget();</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY, SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> <span class="title class_">DefaultReflectorFactory</span>());</span><br><span class="line">        <span class="type">MappedStatement</span> <span class="variable">mappedStatement</span> <span class="operator">=</span> (MappedStatement) metaObject.getValue(<span class="string">&quot;delegate.mappedStatement&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自定义注解判断是否进行分表操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> mappedStatement.getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> id.substring(<span class="number">0</span>, id.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 获取SQL</span></span><br><span class="line">        <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> statementHandler.getBoundSql();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换SQL表名 USER 为 USER_03</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(sql);</span><br><span class="line">        <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            tableName = matcher.group().trim();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">null</span> != tableName;</span><br><span class="line">        <span class="type">String</span> <span class="variable">replaceSql</span> <span class="operator">=</span> matcher.replaceAll(tableName + <span class="string">&quot;_&quot;</span> + DBContextHolder.getTbKey());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射修改SQL语句</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> boundSql.getClass().getDeclaredField(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(boundSql, replaceSql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
            <tag> Java </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zerotier的使用</title>
      <link href="/2022/02/07/Zerotier%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/07/Zerotier%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="在线安装zerotier"><a href="#在线安装zerotier" class="headerlink" title="在线安装zerotier"></a>在线安装zerotier</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | sudo bash</span><br></pre></td></tr></table></figure><h2 id="查看安装zerotier版本"><a href="#查看安装zerotier版本" class="headerlink" title="查看安装zerotier版本"></a>查看安装zerotier版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo zerotier-cli status</span><br></pre></td></tr></table></figure><h2 id="加入一个netWork"><a href="#加入一个netWork" class="headerlink" title="加入一个netWork"></a>加入一个netWork</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo zerotier-cli join ################（networkid）</span><br></pre></td></tr></table></figure><h2 id="查看加入的网络的信息，比如network"><a href="#查看加入的网络的信息，比如network" class="headerlink" title="查看加入的网络的信息，比如network"></a>查看加入的网络的信息，比如network</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo zerotier-cli listnetworks</span><br></pre></td></tr></table></figure><h2 id="退出加入的network网段"><a href="#退出加入的network网段" class="headerlink" title="退出加入的network网段"></a>退出加入的network网段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo zerotier-cli leave ################（networkid）</span><br></pre></td></tr></table></figure><h2 id="启动、停止服务"><a href="#启动、停止服务" class="headerlink" title="启动、停止服务"></a>启动、停止服务</h2><p><strong>(mac下，linux尝试发现没有launchctl command)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stop and start the service with launchctl</span></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">sudo launchctl unload /Library/LaunchDaemons/com.zerotier.one.plist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo launchctl load /Library/LaunchDaemons/com.zerotier.one.plist</span><br></pre></td></tr></table></figure><h2 id="卸载服务（未尝试）"><a href="#卸载服务（未尝试）" class="headerlink" title="卸载服务（未尝试）"></a>卸载服务（未尝试）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cleanly uninstall ZeroTier One, preserving only your secret identity</span></span><br><span class="line"></span><br><span class="line">sudo <span class="string">&quot;/Library/Application Support/ZeroTier/One/uninstall.sh&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具与中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zerotier </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
