{"meta":{"title":"贺墨于的博客","subtitle":"","description":"","author":"贺墨于","url":"https://motang.top","root":"/"},"pages":[{"title":"关于","date":"2023-10-16T09:17:29.237Z","updated":"2023-10-16T09:17:29.237Z","comments":false,"path":"about/index.html","permalink":"https://motang.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-10-17T07:32:13.073Z","updated":"2023-10-17T07:32:13.073Z","comments":false,"path":"books/index.html","permalink":"https://motang.top/books/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-11T14:59:22.580Z","updated":"2022-05-11T14:59:22.580Z","comments":true,"path":"404/index.html","permalink":"https://motang.top/404/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-04T16:00:00.000Z","updated":"2022-05-11T14:27:23.804Z","comments":true,"path":"tags/index.html","permalink":"https://motang.top/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-01-28T11:22:02.218Z","updated":"2022-02-07T12:49:27.629Z","comments":true,"path":"links/index.html","permalink":"https://motang.top/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-05-12T01:42:50.708Z","updated":"2022-02-07T12:49:27.630Z","comments":false,"path":"repository/index.html","permalink":"https://motang.top/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-04T16:00:00.000Z","updated":"2023-10-17T07:27:46.454Z","comments":true,"path":"categories/index.html","permalink":"https://motang.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringSecurity认证流程","slug":"SpringSecurity认证流程","date":"2023-10-24T14:49:47.982Z","updated":"2023-10-24T14:54:44.436Z","comments":true,"path":"2023/10/24/SpringSecurity认证流程/","link":"","permalink":"https://motang.top/2023/10/24/SpringSecurity%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/","excerpt":"","text":"最近在学习 Ruoyi 后台管理框架源码，看到了关于 SpringSecurity 安全认证方面的东西，感觉不易理解，因此花了点时间时间看了源码，深入了解一下认证流程 SpringSecurity配置 我们需要做一定的配置才能让 SpringSecurity 的安全认证起到作用，下面我们定义一个 SecurityConfig.java 类，它继承了 WebSecurityConfigurerAdapter，如下： 1234@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter&#123; ...&#125; Step.1）同时需要重写它的 configure(HttpSecurity http) 方法： 1234567891011121314@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; // CRSF禁用，不使用session http.csrf().disable(); // 基于token，所以不需要session http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); // 过滤请求 http.authorizeRequests() .antMatchers(&quot;/login&quot;, &quot;/captchaImage&quot;).anonymous() .anyRequest().authenticated(); .... // 添加JWT filter http.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);&#125; 配置的相关解释如下： 项目是前后端分离的，无需用到 session，因此修改与 session 相关的配置 定义哪些请求需要进行认证，哪些请求可以放行 定义过滤器（重要，如何从请求中拿到认证信息就靠它了） 在项目中过滤器 authenticationTokenFilter 继承了 OncePerRequestFilter 继承了 OncePerRequestFilter 的类在每次请求只执行一次 Step.2）此外我们还需要重写的它的 configure(AuthenticationManagerBuilder auth) 方法： 123456@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception&#123; auth.userDetailsService(userDetailsService) .passwordEncoder(bCryptPasswordEncoder());&#125; 在这里我们使用了一个 UserDetailsService 对象（重要，判断用户认证是否成功也就是账号密码是否正确就靠它了） 小总结：目前我们提到了两个重要，下面的文章就是围绕这两个重要进行展开的。下面我们将先阐述用户认证流程，然后在梳理如何拿到认证信息。 用户认证流程 用户认证所关注是用户所输入的账号信息是否正确，如果账号信息正确将返回一个凭证，下面的认证流程将围绕这个关注点展开。 「发送认证请求」 我们发送请求 [post] /login，传递 username、password 等数据到服务器，服务器收到请求，来到相应的 controller 处理方法 12345678910111213@RestControllerpublic class SysLoginController &#123; @Autowired private SysLoginService loginService; @PostMapping(&quot;login&quot;) public Result login(String username, String password, String code, String uuid)&#123; Result result = Result.success(); String token = loginService.login(username, password, code, uuid); result.put(Constants.TOKEN, token); return result; &#125; 在这里调用 loginService 的 login方法，其中内部是具体的验证登录逻辑，验证通过后返回一个 token，也就是一个凭证，用来表示我们已近认证成功（登录成功）。 「调用认证方法」 接下来进入 loginService.login()内 123456789101112131415161718192021222324@Componentpublic class SysLoginService &#123; @Autowired private RedisCache redisCache; @Autowired private TokenService tokenService; @Autowired private AuthenticationManager authenticationManager; public String login(String username, String password, String code, String uuid) &#123; ...省去验证码校验逻辑，校验失败会抛出异常 Authentication authenticate = null; try &#123; // 认证 该方法会去调用UserDetailsServiceImpl.loadUserByUsername authenticate = authenticationManager.authenticate( new UsernamePasswordAuthenticationToken(username, password)); &#125; catch (Exception e) &#123; if (e instanceof BadCredentialsException) &#123; throw new UserPasswordNotMatchException(); &#125; else &#123; throw new CustomException(e.getMessage()); &#125; &#125; return tokenService.createToken((LoginUser) authenticate.getPrincipal()); &#125;&#125; 其中 authenticationManager.authenticate() 就是我们需要调用的认证方法，如果失败则抛出异常。 这个方法以一个 UsernamePasswordAuthenticationToken 类作为参数，它拥有两个构造方法，如下： 只有两个参数的构造方法表示「当前没有认证」 1public UsernamePasswordAuthenticationToken(Object principal, Object credentials) 有三个参数的构造方法表示「当前已经认证完毕」，后面校验成功后会用到它 「源码分析认证方法」 上面的流程图就是认证方法的一个大概过程，下面我们将通过源码来查看这个认证方法 AuthenticationManager.authenticate() 到底干了什么（深入源码调用堆栈有点啰嗦，可以直接看第5步的小总结）。 Step.1）实现了AuthenticationMananger的ProviderManger调用接口的authenticate方法 Step.2）然后遍历所有的 AuthenticProvider，其中的supports方法用来判断 provider 是否支持 toTest。 而源码中的 toTest 类，就是我们认证传递的 UsernamePasswordAuthenticationToken，通过遍历我们发现 AbstractUserDetailsAuthenticationProvider 支持 UsernamePasswordAuthenticationToken，判断provider是否合适的源码如下： AbstractUserDetailsAuthenticationProvider.java 1234@Overridepublic boolean supports(Class&lt;?&gt; authentication) &#123; return (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication));&#125; Step.3）找到合适的Provider后，在本例中也即是AbstractUserDetailsAuthenticationProvider（抽象类），会调用provider 的authenticate 方法 Step.4）从下面可以看到 retrieveUser 方法返回一个 UserDetails Step.5）接着深入，可以发现 DaoAuthenticationProvider 继承了 AbstractUserDetailsAuthenticationProvider，所以DaoAuthenticationProvider 才是真正的实现类，他会调用 retrieveUser 方法，接着调用 loaderUserByUsername() 方法 看到 loaderUserByUsername()，应该就很熟悉了，因为这就是我们自己实现 UserDetailsService 接口，自定义的认证过程。 小总结：源码分析了一堆，其实这个认证方法的真正目的是调用 UserDetailsService 类的 loaderUserByUsername() 「实现校验逻辑」 文章开头我们提到了两个重要，第二个重要就是 UserDetailsService，认证就是通过它的 loaderUserByUsername() 方法是否认证成功。 UserDetailsService 是一个接口，同时要求我们返回一个 UserDetail 对象，我们需要自己实现认证校验逻辑，如下： 1234567891011121314151617181920212223242526@Service(&quot;userDetailsService&quot;)public class UserDetailServiceImpl implements UserDetailsService &#123; ... @Autowired private ISysUserService userService; @Autowired private SysPermissionService permissionService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; SysUser user = userService.selectUserByUserName(username); if (null == user) &#123; log.info(&quot;登录用户：&#123;&#125; 不存在.&quot;, username); throw new UsernameNotFoundException(&quot;登录用户：&quot; + username + &quot; 不存在&quot;); &#125; else if (UserStatus.DELETED.getCode().equals(user.getDelFlag())) &#123; log.info(&quot;登录用户：&#123;&#125; 已被删除.&quot;, username); throw new BaseException(&quot;对不起，您的账号：&quot; + username + &quot; 已被删除&quot;); &#125; else if (UserStatus.DISABLE.getCode().equals(user.getStatus())) &#123; log.info(&quot;登录用户：&#123;&#125; 已被停用.&quot;, username); throw new BaseException(&quot;对不起，您的账号：&quot; + username + &quot; 已停用&quot;); &#125; return createLoginUser(user); &#125; public UserDetails createLoginUser(SysUser user) &#123; return new LoginUser(user, permissionService.getMenuPermission(user)); &#125;&#125; 上面就是我们自己的认证逻辑： 通过一个唯一标识 username 查询用户 当所有校验都通过后就会调用 createLoginUser 方法 装填用户拥有的权限以及从数据库中获取的密码， 返回一个 LoginUser 对象，而这个对象实现了 UserDetails接口。 「源码分析校验逻辑」 下面我们通过源码查看获取到 UserDetails 后 SpringSecurity 还做了什么（如果没看之前的源码分析可以直接看第2步的小总结） Step.1）我们回看 AbstractUserDetailsAuthenticationProvider 的 authenticate 方法 Step.2）接着深入，可以发现createSuccessAuthentication方法创建了一个UsernamePasswordAuthenticationToken，并且他的构造方法有三个参数，这表明这个token是已近认证过后的 小总结：认证成功后，我们调用 UsernamePasswordAuthenticationToken 具有三个参数的构造方法，也就是代表认证成功的构造函数，然后将构造的对象返回去。 「认证结束」 至此认证已经结束，我再回到 loginService.login()这个我们自己写的方法内，认证方法 authenticationManager.authenticate() 认证成功后会返回一个 Authentication，然后就可以利用这个 Authentication 生成一个 token。 loginService.java 1return tokenService.createToken((LoginUser) authenticate.getPrincipal()); 接着回到前面第二步controller调用的 loginService.login()，这时它已近拿到了 token ，于是将其返回到前端。前端收到相应后，就可以把这个token存在本地，以后每次访问请求时都带上这个token 信息。 1234567@PostMapping(&quot;login&quot;)public AjaxResult login(String username, String password, String code, String uuid)&#123; AjaxResult result = AjaxResult.success(); String token = loginService.login(username, password, code, uuid); result.put(Constants.TOKEN, token); return result;&#125; 获取认证信息 文章开头提到了两个重要，下面我们将梳理第一个重要，也就是如何从请求中拿到认证信息。 上面说到认证成功后每次发送请求都带上 token 信息，但是为啥带上这个 token 呢？在之前的 SpringSecurity 配置中有如下配置 1.antMatchers(&quot;/login&quot;, &quot;/captchaImage&quot;).anonymous() 因此对于 /login请求没遭受拦截，而其他请求都是要被拦截的。 「拦截器」 之前 /login 我们配置了不拦截，因此手动调用 authenticationManager.authenticate() 来进行认证，而现在被拦截的请求又是如何判断它是否认证过了呢？ 对于被拦截的请求，如果它带有 token，我们会手动将这个 token 转换为认证信息 UsernamePasswordAuthenticationToken 并放入本次请求的上下文中，否则啥事都不做。而我们文章开头所配置的 1http.addFilterBefore(authenticationTokenFilter,UsernamePasswordAuthenticationFilter.class); 拦截器就是起这个作用，具体实现如下（后面称这个为 jwtFilter）。 JwtAuthenticationTokenFilter.java 1234567891011121314151617181920212223@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private TokenService tokenService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; // 1) LoginUser loginUser = tokenService.getLoginUser(request); // 2) if (ObjectUtil.isNotNull(loginUser) &amp;&amp; ObjectUtil.isNull(SecurityUtils.getAuthentication())) &#123; // 3.1) tokenService.verifyToken(loginUser); // 3.2) UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities()); authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authenticationToken); &#125; chain.doFilter(request, response); &#125;&#125; 我们关注代码中 3.2）即可。在 token 正确后，我们使用用有三个参数的构造方法创建UsernamePasswordAuthenticationToken 对象，前面也说了，这代表已经经过认证，然后通过 SecurityContextHolder.getContext().setAuthentication() 为本次请求上下文设置一下认证信息。 这样后面 SpringSecurity 看到存在这个认证信息就会判断本次请求已经认证成功。 「源码分析拦截流程」 为了更深刻的了解 SpringSecurity 内部是如何被拦截请求是否认证成功，我们接下来通过源码具体分析一下流程。 再次之前先介绍一个类 FilterSecurityInterceptor：是一个方法级的权限过滤器，基本位于过滤链的最底部，因此请求到来时它一定会执行，下面来看看源码。 下面来打个断点，查看一下 这说明来到beforeInvocation方法时我们前面编写的jwtFilter已经被执行，认证信息已近被手动添加过了 进入beforeInvocation()里面，由调试信息可以看到当前请求需要被认证 接着我们进入authenticateIfRequired方法的内部 因为我们之前 jwtfilter 手动添加了认证信息，所以authenticateIfRequired就直接返回了authentication，表示认证通过。 如果之前在 jwtfilter 被拦截的请求不存在 token，我们就不会手动设置认证信息，因此调用 authenticationManager.authenticate();进行验证时，中途一定会抛出异常，导致此次请求失败被拦截 至此也没啥好讲了，filterInvocation.getChain().doFilter() 调用我们的后台服务了 参考 https://www.cnblogs.com/ymstars/p/10626786.html https://www.jianshu.com/p/d5ce890c67f7 https://gitee.com/y_project/RuoYi-Vue","categories":[{"name":"Spring家族","slug":"Spring家族","permalink":"https://motang.top/categories/Spring%E5%AE%B6%E6%97%8F/"},{"name":"SpringSecurity","slug":"Spring家族/SpringSecurity","permalink":"https://motang.top/categories/Spring%E5%AE%B6%E6%97%8F/SpringSecurity/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://motang.top/tags/Java/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://motang.top/tags/SpringSecurity/"}]},{"title":"简单的分库分表实践案例","slug":"简单的分库分表实现案例","date":"2023-10-24T11:48:32.735Z","updated":"2023-10-24T11:58:06.574Z","comments":true,"path":"2023/10/24/简单的分库分表实现案例/","link":"","permalink":"https://motang.top/2023/10/24/%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B/","excerpt":"","text":"由于业务庞大，数据增长快，为了缓解数据库压力需要进行分库分表。本文的目标是展示一个具体的数据库路由组件的实践案例。这个案例通过自定义一个 springboot 的 starter 来实现。 什么是分库分表？ 分库分表其实很好理解，「顾名思义，即把存于一个库的数据分散到多个库中，把存于一个表的数据分散到多个表中」。分库分表有三种方案： 「只分库不分表」 「只分表不分库」 「既分库又分表」 只分库不分表 「从单个数据库拆分成多个数据库的过程，将数据散落在多个数据库中，多个数据库同时提供服务」 只分表不分库 「从单张表拆分成多张表的过程，将数据散落在多张表内」 既分库又分表 「把存于一个数据库的单表数据分散到不同库的多个表中」 配置 确定需要数据 知道了分库分表的概念，我们就可以确定 starter 所需要的数据了 123456789101112131415161718192021222324mini-db-router: jdbc: datasource: db-count: 2 tb-count: 4 router-key: uId default-db: db00 list: db01,db02 db-config-map: db00: url: jdbc:mysql://192.168.56.101:3306/lottery?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver db01: url: jdbc:mysql://192.168.56.101:3306/lottery_01?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver db02: url: jdbc:mysql://192.168.56.101:3306/lottery_02?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver dbCount：分库数 tbCount：分表数 routerKey：路由键，用来确定哪一个库，哪一个表 defaultDb：默认数据库 list：分库数据库列表 dbConfigMap：数据库配置 创建 Properties 为了读取在 yaml 文件中的配置，我们创建 Properties 来帮助我们便捷的读取 yaml 数据。 123456789101112131415161718192021222324252627282930313233343536@Data@Component@ConfigurationProperties(prefix = &quot;mini-db-router.jdbc.datasource&quot;)public class DBRouterProperties &#123; private Integer dbCount; private Integer tbCount; private String list; private String defaultDb; /** * 路由字段 */ private String routerKey; private Map&lt;String, DbConfig&gt; dbConfigMap; public DbConfig getDefaultDbConfig() &#123; return dbConfigMap.get(defaultDb); &#125; public DbConfig getDbConfig(String dbKey) &#123; return dbConfigMap.get(dbKey); &#125; @Data public static class DbConfig &#123; private String driverClassName; private String url; private String username; private String password; &#125;&#125; 运行时如何决定库表？ 程序运行时我们需要判断具体要选择哪一个库，以及哪一个表，在这里就需要用到 ThreadLocal，它在线程中维护一个变量，并且能在同一线程中的任意上下文获取到这个变量，还起到线程间数据隔离的作用。 我们将 dbKey 以及 tbKey 用 TreadLocal 维护起来，它们两分别决定了该使用哪个库哪个表，如下： 123456789101112131415161718192021222324252627282930public class DBContextHolder &#123; private static final ThreadLocal&lt;String&gt; dbKey = new ThreadLocal&lt;String&gt;(); private static final ThreadLocal&lt;String&gt; tbKey = new ThreadLocal&lt;String&gt;(); public static void setDbKey(String key) &#123; dbKey.set(key); &#125; public static String getDbKey() &#123; return dbKey.get(); &#125; public static void setTbKey(String key) &#123; tbKey.set(key); &#125; public static String getTbKey() &#123; return tbKey.get(); &#125; public static void clearDbKey() &#123; dbKey.remove(); &#125; public static void clearTbKey() &#123; tbKey.remove(); &#125;&#125; 这里我们只提到了如何维护 dbKey 和 tbKey，后面会再次说明如何设置以及使用这两个值 设置 dbKey 以及 tbKey 前面提到可以说用 DBContextHolder 来维护 dbKey 以及 tbKey 这两个值，那何时去设置它们呢，这就要用到注解以及 aop 了。 只要在方法上标注了注解就说明我们想要分库分表了，然后借助 aop 就可以在执行数据库操作之前设置好 dbKey 以及 tbKey 这两个值。 注解 @DBRouter 表明我们想要分库，同时可以用 key 来指定路由键 1234567@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface DBRouter &#123; String key() default &quot;&quot;;&#125; @DBRouterStrategy 表明我们想要分表 12345678@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface DBRouterStrategy &#123; boolean splitTable() default false;&#125; 创建切面 1、切点 123@Pointcut(&quot;@annotation(com.hemou.middleware.db.router.annotation.DBRouter)&quot;)public void aopPoint() &#123;&#125; 我们对标注了 @DBRouter 的地方进行增强 2、通知 我们使用环绕通知 1）我们获取 @DBRouter 上表明的路由键，若为空，则使用 yaml 中配置的默认路由键 2）通过路由键我们获取对应的路由值，大多数是全局唯一ID 3）根据路由值计算该路由到哪个库哪个表，（也就是设置 dbKey 以及 tbKey） 4）执行原本方法 5）原方法执行完毕后，清除 dbKey 以及 tbKey，避免内存泄露 1234567891011121314151617181920@Around(&quot;aopPoint() &amp;&amp; @annotation(dbRouter)&quot;)public Object doRouter(ProceedingJoinPoint jp, DBRouter dbRouter) throws Throwable &#123; String dbKey = dbRouter.key(); dbKey = StringUtils.isNotBlank(dbKey) ? dbKey : dbRouterProperties.getRouterKey(); if (StringUtils.isBlank(dbKey)) &#123; throw new RuntimeException(&quot;annotation DBRouter key is null!&quot;); &#125; // 计算路由 String dbKeyValue = this.getAttrValue(dbKey, jp.getArgs()); dbRouterStrategy.doRouter(dbKeyValue); // 执行方法 try &#123; return jp.proceed(); &#125; finally &#123; // 清除路由 dbRouterStrategy.clear(); &#125;&#125; 3、具体路由值计算该路由到哪个库哪个表的方法 先通过 dbCount 以及 tbCount size，这个size必须是 2 的 n 次幂 12345678910111213@Overridepublic void doRouter(String dbKeyAttr) &#123; int size = dbRouterProperties.getDbCount() * dbRouterProperties.getTbCount(); int idx = (size - 1) &amp; (dbKeyAttr.hashCode() ^ (dbKeyAttr.hashCode() &gt;&gt;&gt; 16)); int dbIdx = idx / dbRouterProperties.getTbCount() + 1; int tbIdx = idx - dbRouterProperties.getTbCount() * (dbIdx - 1); DBContextHolder.setDbKey(String.format(&quot;%02d&quot;, dbIdx)); DBContextHolder.setTbKey(String.format(&quot;%03d&quot;, tbIdx)); log.debug(&quot;数据库路由 dbIdx：&#123;&#125; tbIdx：&#123;&#125;&quot;, dbIdx, tbIdx);&#125; 分库 - 数据库动态切换 因为进行了分库，所以数据库不止一个，这里我们就可以根据 dbKey 来决定到底使用哪一个库了。我们将继承一个 AbstractRoutingDataSource 类，它的 determineCurrentLookupKey() 方法能帮我们动态的切换数据库，如下： 1234567891011121314151617public class DynamicDataSource extends AbstractRoutingDataSource &#123; private final DBRouterProperties dbRouterProperties; public DynamicDataSource(DBRouterProperties dbRouterProperties) &#123; this.dbRouterProperties = dbRouterProperties; &#125; @Override protected Object determineCurrentLookupKey() &#123; if (null == DBContextHolder.getDbKey()) &#123; return dbRouterProperties.getDefaultDb(); &#125; else &#123; return &quot;db&quot; + DBContextHolder.getDbKey(); &#125; &#125;&#125; 在这里我们判断 DBContextHolder 维护的 dbKey 是否为空，如果为空则使用默认数据库，否则使用指定数据库。 我们所继承的这个 AbstractRoutingDataSource 构建时要求我们输入一个 Map 集合，它键对应的值就是数据源对象，如下： 12345678910111213141516@Beanpublic DataSource dataSource(DBRouterProperties dbRouterProperties) &#123; // 创建数据源 Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); for (Map.Entry&lt;String, DbConfig&gt; entry : dbRouterProperties.getDbConfigMap().entrySet()) &#123; DbConfig dbConfig = entry.getValue(); targetDataSources.put(entry.getKey(), new DriverManagerDataSource(dbConfig.getUrl(), dbConfig.getUsername(), dbConfig.getPassword())); &#125; // 设置数据源 DynamicDataSource dynamicDataSource = new DynamicDataSource(dbRouterProperties); dynamicDataSource.setTargetDataSources(targetDataSources); dynamicDataSource.setDefaultTargetDataSource(targetDataSources.get(dbRouterProperties.getDefaultDb())); return dynamicDataSource;&#125; 因此 determineCurrentLookupKey() 就可以根据 dbKey 来决定具体的数据源 分表 通过创建 Mybatis 插件以及维护的 tbKey，我们为 SQL 语句所操作的数据表动态的添加后缀，从而起到分表的作用。 123456789101112131415161718192021222324252627282930313233343536373839@Intercepts(&#123;@Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class, Integer.class&#125;)&#125;)public class DynamicMybatisPlugin implements Interceptor &#123; private final Pattern pattern = Pattern.compile(&quot;(from|into|update)[\\\\s]+(\\\\w+)&quot;, Pattern.CASE_INSENSITIVE); @Override public Object intercept(Invocation invocation) throws Throwable &#123; // 获取StatementHandler StatementHandler statementHandler = (StatementHandler) invocation.getTarget(); MetaObject metaObject = MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY, SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY, new DefaultReflectorFactory()); MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(&quot;delegate.mappedStatement&quot;); // 获取自定义注解判断是否进行分表操作 String id = mappedStatement.getId(); String className = id.substring(0, id.lastIndexOf(&quot;.&quot;)); Class&lt;?&gt; clazz = Class.forName(className); // 获取SQL BoundSql boundSql = statementHandler.getBoundSql(); String sql = boundSql.getSql(); // 替换SQL表名 USER 为 USER_03 Matcher matcher = pattern.matcher(sql); String tableName = null; if (matcher.find()) &#123; tableName = matcher.group().trim(); &#125; assert null != tableName; String replaceSql = matcher.replaceAll(tableName + &quot;_&quot; + DBContextHolder.getTbKey()); // 通过反射修改SQL语句 Field field = boundSql.getClass().getDeclaredField(&quot;sql&quot;); field.setAccessible(true); field.set(boundSql, replaceSql); return invocation.proceed(); &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://motang.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"分库分表","slug":"分库分表","permalink":"https://motang.top/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"},{"name":"Java","slug":"Java","permalink":"https://motang.top/tags/Java/"},{"name":"后台","slug":"后台","permalink":"https://motang.top/tags/%E5%90%8E%E5%8F%B0/"}]},{"title":"Zerotier的使用","slug":"Zerotier的使用","date":"2022-02-07T12:41:28.000Z","updated":"2023-10-24T07:43:40.367Z","comments":true,"path":"2022/02/07/Zerotier的使用/","link":"","permalink":"https://motang.top/2022/02/07/Zerotier%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在线安装zerotier1curl -s https://install.zerotier.com | sudo bash 查看安装zerotier版本1sudo zerotier-cli status 加入一个netWork1sudo zerotier-cli join ################（networkid） 查看加入的网络的信息，比如network1sudo zerotier-cli listnetworks 退出加入的network网段1sudo zerotier-cli leave ################（networkid） 启动、停止服务(mac下，linux尝试发现没有launchctl command) 123456# Stop and start the service with launchctl# 停止sudo launchctl unload /Library/LaunchDaemons/com.zerotier.one.plist# 启动sudo launchctl load /Library/LaunchDaemons/com.zerotier.one.plist 卸载服务（未尝试）123# Cleanly uninstall ZeroTier One, preserving only your secret identitysudo &quot;/Library/Application Support/ZeroTier/One/uninstall.sh&quot;","categories":[{"name":"工具与中间件","slug":"工具与中间件","permalink":"https://motang.top/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"zerotier","slug":"zerotier","permalink":"https://motang.top/tags/zerotier/"}]}],"categories":[{"name":"Spring家族","slug":"Spring家族","permalink":"https://motang.top/categories/Spring%E5%AE%B6%E6%97%8F/"},{"name":"SpringSecurity","slug":"Spring家族/SpringSecurity","permalink":"https://motang.top/categories/Spring%E5%AE%B6%E6%97%8F/SpringSecurity/"},{"name":"数据库","slug":"数据库","permalink":"https://motang.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"工具与中间件","slug":"工具与中间件","permalink":"https://motang.top/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://motang.top/tags/Java/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://motang.top/tags/SpringSecurity/"},{"name":"分库分表","slug":"分库分表","permalink":"https://motang.top/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"},{"name":"后台","slug":"后台","permalink":"https://motang.top/tags/%E5%90%8E%E5%8F%B0/"},{"name":"zerotier","slug":"zerotier","permalink":"https://motang.top/tags/zerotier/"}]}